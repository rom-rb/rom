module DataMapper
  class Engine
    module Arel

      # Arel Gateway is an object wrapping both Arel::Table and Arel::SelectManager
      # providing common API for relation graph nodes
      #
      # A gateway instance can be used to run queries or execute insert/update/delete
      # operations.
      #
      # @example
      #
      #   relation = Arel::Table.new(
      #     :users, Class.new(ActiveRecord::Base) { self.table_name = 'users' }
      #   )
      #   header  = relation.columns
      #   gateway = Engine::Arel::Gateway.new(:users, relation, header)
      #
      #   # iterate over all users
      #   gateway.each { |user_row| # do something here }
      #
      #   # restrict users
      #   gateway.restrict(relation[:name].eq('Piotr')).each { |user_row| # ... }
      #
      #   # insert new user row
      #   gateway.insert(:name => 'Piotr', :age => 29) # returns pk value
      #
      #   # delete users matching given criteria
      #   gateway.delete(:id => 1)
      #
      class Gateway
        include Enumerable

        # Returns name of the wrapped relation
        #
        # @api private
        attr_reader :name

        # Returns header of the wrapped relation
        #
        # @api private
        attr_reader :header

        # Returns wrapped relation. This can be a base relation or a "virtual" one
        #
        # @api private
        attr_reader :relation

        # Initializes a gateway instance
        #
        # @param [Symbol, #to_sym] name
        # @param [::Arel::Table,::Arel::SelectManager] relation
        # @param [Array] header
        #
        # @api private
        def initialize(name, relation, header)
          @relation = relation
          @name     = name.to_sym
          @header   = header
        end

        # Iterates over rows returned by the wrapped relation
        #
        # @api public
        def each(&block)
          return to_enum unless block_given?
          read.each(&block)
          self
        end

        # Returns new gateway instance
        #
        # @api private
        def new(relation, header = @header)
          self.class.new(name, relation, header)
        end

        # Returns restricted relation
        #
        # @api public
        def restrict(conditions, &block)
          with_restriction(conditions) { |restriction|
            restriction = yield(restriction) if block_given?
            new(restriction)
          }
        end

        # @api public
        def order(*fields)
          new(relation.order(*fields))
        end

        # Apply limit to the relation
        #
        # @param [Integer]
        #
        # @api public
        def take(limit)
          new(relation.take(limit))
        end

        # Apply offset to the relation
        #
        # @param [Integer]
        #
        # @api public
        def skip(offset)
          new(relation.skip(offset))
        end

        # Inserts a new row
        #
        # @param [Hash] tuple
        #
        # @api public
        def insert(tuple)
          binds = tuple.to_a.map { |a| [ relation[a.first], a.last ] }
          stmt  = relation.create_insert

          stmt.into(relation)
          stmt.insert(binds)

          connection.insert(stmt, 'SQL')
        end

        def update(conditions, tuple)
          binds = tuple.to_a.map { |a| [ relation[a.first], a.last ] }

          stmt = with_restriction(conditions) { |restriction|
            restriction.compile_update(binds)
          }

          connection.update(stmt, 'SQL')
        end

        # Deletes a row matching given criteria
        #
        # @api public
        def delete(conditions)
          with_restriction(conditions) { |restriction| restriction.delete }
        end

        # @api public
        def join(other, keys)
          new(relation.clone.join(other.relation).on(keys))
        end

        # @api public
        def on(keys)
          new(relation.on(keys))
        end

        # @api public
        def project(header)
          new(relation, header)
        end

        # @api public
        def [](name)
          relation[name]
        end

        # @api public
        def where(conditions)
          new(relation.where(conditions))
        end

        private

        # Executes sql query generated by the wrapped relation
        #
        # @api private
        def read
          connection.execute(to_sql)
        end

        # Generates an sql query
        #
        # @api private
        def to_sql
          relation.project(header.map(&:name).join(', ')).to_sql
        end

        # Returns database connection used by the wrapped relation
        #
        # @api private
        def connection
          relation.engine.connection
        end

        # @api private
        def with_restriction(conditions, &block)
          restriction = relation.clone
          conditions.each do |key, value|
            restriction = restriction.where(relation[key].eq(value))
          end
          yield(restriction)
        end

      end # class Gateway

    end # module Arel
  end # class Engine
end # module DataMapper
